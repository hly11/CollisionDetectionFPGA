-- ==============================================================
-- RTL generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
-- Version: 2015.1
-- Copyright (C) 2015 Xilinx Inc. All rights reserved.
-- 
-- ===========================================================

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity image_filter_fh_Block_Mat_exit71218_proc is
port (
    ap_clk : IN STD_LOGIC;
    ap_rst : IN STD_LOGIC;
    ap_start : IN STD_LOGIC;
    ap_done : OUT STD_LOGIC;
    ap_continue : IN STD_LOGIC;
    ap_idle : OUT STD_LOGIC;
    ap_ready : OUT STD_LOGIC;
    filter_size : IN STD_LOGIC_VECTOR (31 downto 0);
    ap_return : OUT STD_LOGIC_VECTOR (5 downto 0) );
end;


architecture behav of image_filter_fh_Block_Mat_exit71218_proc is 
    constant ap_const_logic_1 : STD_LOGIC := '1';
    constant ap_const_logic_0 : STD_LOGIC := '0';
    constant ap_ST_st1_fsm_0 : STD_LOGIC_VECTOR (2 downto 0) := "001";
    constant ap_ST_st2_fsm_1 : STD_LOGIC_VECTOR (2 downto 0) := "010";
    constant ap_ST_st3_fsm_2 : STD_LOGIC_VECTOR (2 downto 0) := "100";
    constant ap_const_lv32_0 : STD_LOGIC_VECTOR (31 downto 0) := "00000000000000000000000000000000";
    constant ap_const_lv1_1 : STD_LOGIC_VECTOR (0 downto 0) := "1";
    constant ap_const_lv32_1 : STD_LOGIC_VECTOR (31 downto 0) := "00000000000000000000000000000001";
    constant ap_const_lv32_9 : STD_LOGIC_VECTOR (31 downto 0) := "00000000000000000000000000001001";
    constant ap_const_lv32_F : STD_LOGIC_VECTOR (31 downto 0) := "00000000000000000000000000001111";
    constant ap_const_lv32_15 : STD_LOGIC_VECTOR (31 downto 0) := "00000000000000000000000000010101";
    constant ap_const_lv32_1B : STD_LOGIC_VECTOR (31 downto 0) := "00000000000000000000000000011011";
    constant ap_const_lv32_27 : STD_LOGIC_VECTOR (31 downto 0) := "00000000000000000000000000100111";
    constant ap_const_lv5_1B : STD_LOGIC_VECTOR (4 downto 0) := "11011";
    constant ap_const_lv5_15 : STD_LOGIC_VECTOR (4 downto 0) := "10101";
    constant ap_const_lv32_2 : STD_LOGIC_VECTOR (31 downto 0) := "00000000000000000000000000000010";
    constant ap_const_lv5_F : STD_LOGIC_VECTOR (4 downto 0) := "01111";
    constant ap_const_lv5_9 : STD_LOGIC_VECTOR (4 downto 0) := "01001";
    constant ap_const_lv6_27 : STD_LOGIC_VECTOR (5 downto 0) := "100111";
    constant ap_const_lv6_33 : STD_LOGIC_VECTOR (5 downto 0) := "110011";

    signal ap_done_reg : STD_LOGIC := '0';
    signal ap_CS_fsm : STD_LOGIC_VECTOR (2 downto 0) := "001";
    attribute fsm_encoding : string;
    attribute fsm_encoding of ap_CS_fsm : signal is "none";
    signal ap_sig_cseq_ST_st1_fsm_0 : STD_LOGIC;
    signal ap_sig_bdd_22 : BOOLEAN;
    signal tmp_s_fu_35_p2 : STD_LOGIC_VECTOR (0 downto 0);
    signal tmp_s_reg_161 : STD_LOGIC_VECTOR (0 downto 0);
    signal ap_sig_bdd_36 : BOOLEAN;
    signal tmp_1_fu_41_p2 : STD_LOGIC_VECTOR (0 downto 0);
    signal tmp_1_reg_168 : STD_LOGIC_VECTOR (0 downto 0);
    signal tmp_2_fu_47_p2 : STD_LOGIC_VECTOR (0 downto 0);
    signal tmp_2_reg_174 : STD_LOGIC_VECTOR (0 downto 0);
    signal tmp_3_fu_53_p2 : STD_LOGIC_VECTOR (0 downto 0);
    signal tmp_3_reg_180 : STD_LOGIC_VECTOR (0 downto 0);
    signal tmp_4_fu_59_p2 : STD_LOGIC_VECTOR (0 downto 0);
    signal tmp_4_reg_185 : STD_LOGIC_VECTOR (0 downto 0);
    signal sel_tmp2_fu_70_p2 : STD_LOGIC_VECTOR (0 downto 0);
    signal sel_tmp2_reg_190 : STD_LOGIC_VECTOR (0 downto 0);
    signal ap_sig_cseq_ST_st2_fsm_1 : STD_LOGIC;
    signal ap_sig_bdd_54 : BOOLEAN;
    signal sel_tmp7_fu_85_p2 : STD_LOGIC_VECTOR (0 downto 0);
    signal sel_tmp7_reg_196 : STD_LOGIC_VECTOR (0 downto 0);
    signal sel_tmp14_fu_101_p2 : STD_LOGIC_VECTOR (0 downto 0);
    signal sel_tmp14_reg_201 : STD_LOGIC_VECTOR (0 downto 0);
    signal sel_tmp1_fu_65_p2 : STD_LOGIC_VECTOR (0 downto 0);
    signal sel_tmp6_demorgan_fu_75_p2 : STD_LOGIC_VECTOR (0 downto 0);
    signal sel_tmp6_fu_79_p2 : STD_LOGIC_VECTOR (0 downto 0);
    signal sel_tmp13_demorgan_fu_90_p2 : STD_LOGIC_VECTOR (0 downto 0);
    signal sel_tmp13_fu_95_p2 : STD_LOGIC_VECTOR (0 downto 0);
    signal ap_sig_cseq_ST_st3_fsm_2 : STD_LOGIC;
    signal ap_sig_bdd_107 : BOOLEAN;
    signal or_cond_fu_113_p2 : STD_LOGIC_VECTOR (0 downto 0);
    signal newSel_fu_106_p3 : STD_LOGIC_VECTOR (4 downto 0);
    signal newSel1_cast_cast_fu_117_p3 : STD_LOGIC_VECTOR (4 downto 0);
    signal newSel5_fu_135_p3 : STD_LOGIC_VECTOR (4 downto 0);
    signal or_cond2_fu_124_p2 : STD_LOGIC_VECTOR (0 downto 0);
    signal or_cond6_fu_147_p2 : STD_LOGIC_VECTOR (0 downto 0);
    signal newSel5_cast_fu_143_p1 : STD_LOGIC_VECTOR (5 downto 0);
    signal newSel3_fu_128_p3 : STD_LOGIC_VECTOR (5 downto 0);
    signal ap_NS_fsm : STD_LOGIC_VECTOR (2 downto 0);


begin




    -- the current state (ap_CS_fsm) of the state machine. --
    ap_CS_fsm_assign_proc : process(ap_clk)
    begin
        if (ap_clk'event and ap_clk =  '1') then
            if (ap_rst = '1') then
                ap_CS_fsm <= ap_ST_st1_fsm_0;
            else
                ap_CS_fsm <= ap_NS_fsm;
            end if;
        end if;
    end process;


    -- ap_done_reg assign process. --
    ap_done_reg_assign_proc : process(ap_clk)
    begin
        if (ap_clk'event and ap_clk =  '1') then
            if (ap_rst = '1') then
                ap_done_reg <= ap_const_logic_0;
            else
                if ((ap_const_logic_1 = ap_continue)) then 
                    ap_done_reg <= ap_const_logic_0;
                elsif ((ap_const_logic_1 = ap_sig_cseq_ST_st3_fsm_2)) then 
                    ap_done_reg <= ap_const_logic_1;
                end if; 
            end if;
        end if;
    end process;


    -- assign process. --
    process (ap_clk)
    begin
        if (ap_clk'event and ap_clk = '1') then
            if ((ap_const_logic_1 = ap_sig_cseq_ST_st2_fsm_1)) then
                sel_tmp14_reg_201 <= sel_tmp14_fu_101_p2;
                sel_tmp2_reg_190 <= sel_tmp2_fu_70_p2;
                sel_tmp7_reg_196 <= sel_tmp7_fu_85_p2;
            end if;
        end if;
    end process;

    -- assign process. --
    process (ap_clk)
    begin
        if (ap_clk'event and ap_clk = '1') then
            if (((ap_const_logic_1 = ap_sig_cseq_ST_st1_fsm_0) and not(ap_sig_bdd_36))) then
                tmp_1_reg_168 <= tmp_1_fu_41_p2;
                tmp_2_reg_174 <= tmp_2_fu_47_p2;
                tmp_3_reg_180 <= tmp_3_fu_53_p2;
                tmp_4_reg_185 <= tmp_4_fu_59_p2;
                tmp_s_reg_161 <= tmp_s_fu_35_p2;
            end if;
        end if;
    end process;

    -- the next state (ap_NS_fsm) of the state machine. --
    ap_NS_fsm_assign_proc : process (ap_CS_fsm, ap_sig_bdd_36)
    begin
        case ap_CS_fsm is
            when ap_ST_st1_fsm_0 => 
                if (not(ap_sig_bdd_36)) then
                    ap_NS_fsm <= ap_ST_st2_fsm_1;
                else
                    ap_NS_fsm <= ap_ST_st1_fsm_0;
                end if;
            when ap_ST_st2_fsm_1 => 
                ap_NS_fsm <= ap_ST_st3_fsm_2;
            when ap_ST_st3_fsm_2 => 
                ap_NS_fsm <= ap_ST_st1_fsm_0;
            when others =>  
                ap_NS_fsm <= "XXX";
        end case;
    end process;

    -- ap_done assign process. --
    ap_done_assign_proc : process(ap_done_reg, ap_sig_cseq_ST_st3_fsm_2)
    begin
        if (((ap_const_logic_1 = ap_done_reg) or (ap_const_logic_1 = ap_sig_cseq_ST_st3_fsm_2))) then 
            ap_done <= ap_const_logic_1;
        else 
            ap_done <= ap_const_logic_0;
        end if; 
    end process;


    -- ap_idle assign process. --
    ap_idle_assign_proc : process(ap_start, ap_sig_cseq_ST_st1_fsm_0)
    begin
        if ((not((ap_const_logic_1 = ap_start)) and (ap_const_logic_1 = ap_sig_cseq_ST_st1_fsm_0))) then 
            ap_idle <= ap_const_logic_1;
        else 
            ap_idle <= ap_const_logic_0;
        end if; 
    end process;


    -- ap_ready assign process. --
    ap_ready_assign_proc : process(ap_sig_cseq_ST_st3_fsm_2)
    begin
        if ((ap_const_logic_1 = ap_sig_cseq_ST_st3_fsm_2)) then 
            ap_ready <= ap_const_logic_1;
        else 
            ap_ready <= ap_const_logic_0;
        end if; 
    end process;

    ap_return <= 
        newSel5_cast_fu_143_p1 when (or_cond6_fu_147_p2(0) = '1') else 
        newSel3_fu_128_p3;

    -- ap_sig_bdd_107 assign process. --
    ap_sig_bdd_107_assign_proc : process(ap_CS_fsm)
    begin
                ap_sig_bdd_107 <= (ap_const_lv1_1 = ap_CS_fsm(2 downto 2));
    end process;


    -- ap_sig_bdd_22 assign process. --
    ap_sig_bdd_22_assign_proc : process(ap_CS_fsm)
    begin
                ap_sig_bdd_22 <= (ap_CS_fsm(0 downto 0) = ap_const_lv1_1);
    end process;


    -- ap_sig_bdd_36 assign process. --
    ap_sig_bdd_36_assign_proc : process(ap_start, ap_done_reg)
    begin
                ap_sig_bdd_36 <= ((ap_start = ap_const_logic_0) or (ap_done_reg = ap_const_logic_1));
    end process;


    -- ap_sig_bdd_54 assign process. --
    ap_sig_bdd_54_assign_proc : process(ap_CS_fsm)
    begin
                ap_sig_bdd_54 <= (ap_const_lv1_1 = ap_CS_fsm(1 downto 1));
    end process;


    -- ap_sig_cseq_ST_st1_fsm_0 assign process. --
    ap_sig_cseq_ST_st1_fsm_0_assign_proc : process(ap_sig_bdd_22)
    begin
        if (ap_sig_bdd_22) then 
            ap_sig_cseq_ST_st1_fsm_0 <= ap_const_logic_1;
        else 
            ap_sig_cseq_ST_st1_fsm_0 <= ap_const_logic_0;
        end if; 
    end process;


    -- ap_sig_cseq_ST_st2_fsm_1 assign process. --
    ap_sig_cseq_ST_st2_fsm_1_assign_proc : process(ap_sig_bdd_54)
    begin
        if (ap_sig_bdd_54) then 
            ap_sig_cseq_ST_st2_fsm_1 <= ap_const_logic_1;
        else 
            ap_sig_cseq_ST_st2_fsm_1 <= ap_const_logic_0;
        end if; 
    end process;


    -- ap_sig_cseq_ST_st3_fsm_2 assign process. --
    ap_sig_cseq_ST_st3_fsm_2_assign_proc : process(ap_sig_bdd_107)
    begin
        if (ap_sig_bdd_107) then 
            ap_sig_cseq_ST_st3_fsm_2 <= ap_const_logic_1;
        else 
            ap_sig_cseq_ST_st3_fsm_2 <= ap_const_logic_0;
        end if; 
    end process;

    newSel1_cast_cast_fu_117_p3 <= 
        ap_const_lv5_F when (sel_tmp2_reg_190(0) = '1') else 
        ap_const_lv5_9;
    newSel3_fu_128_p3 <= 
        ap_const_lv6_27 when (tmp_4_reg_185(0) = '1') else 
        ap_const_lv6_33;
    newSel5_cast_fu_143_p1 <= std_logic_vector(resize(unsigned(newSel5_fu_135_p3),6));
    newSel5_fu_135_p3 <= 
        newSel_fu_106_p3 when (or_cond_fu_113_p2(0) = '1') else 
        newSel1_cast_cast_fu_117_p3;
    newSel_fu_106_p3 <= 
        ap_const_lv5_1B when (sel_tmp14_reg_201(0) = '1') else 
        ap_const_lv5_15;
    or_cond2_fu_124_p2 <= (sel_tmp2_reg_190 or tmp_s_reg_161);
    or_cond6_fu_147_p2 <= (or_cond_fu_113_p2 or or_cond2_fu_124_p2);
    or_cond_fu_113_p2 <= (sel_tmp14_reg_201 or sel_tmp7_reg_196);
    sel_tmp13_demorgan_fu_90_p2 <= (sel_tmp6_demorgan_fu_75_p2 or tmp_2_reg_174);
    sel_tmp13_fu_95_p2 <= (sel_tmp13_demorgan_fu_90_p2 xor ap_const_lv1_1);
    sel_tmp14_fu_101_p2 <= (tmp_3_reg_180 and sel_tmp13_fu_95_p2);
    sel_tmp1_fu_65_p2 <= (tmp_s_reg_161 xor ap_const_lv1_1);
    sel_tmp2_fu_70_p2 <= (tmp_1_reg_168 and sel_tmp1_fu_65_p2);
    sel_tmp6_demorgan_fu_75_p2 <= (tmp_s_reg_161 or tmp_1_reg_168);
    sel_tmp6_fu_79_p2 <= (sel_tmp6_demorgan_fu_75_p2 xor ap_const_lv1_1);
    sel_tmp7_fu_85_p2 <= (tmp_2_reg_174 and sel_tmp6_fu_79_p2);
    tmp_1_fu_41_p2 <= "1" when (filter_size = ap_const_lv32_F) else "0";
    tmp_2_fu_47_p2 <= "1" when (filter_size = ap_const_lv32_15) else "0";
    tmp_3_fu_53_p2 <= "1" when (filter_size = ap_const_lv32_1B) else "0";
    tmp_4_fu_59_p2 <= "1" when (filter_size = ap_const_lv32_27) else "0";
    tmp_s_fu_35_p2 <= "1" when (filter_size = ap_const_lv32_9) else "0";
end behav;
