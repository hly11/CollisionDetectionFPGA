/*********************************************************** 
*  --- OpenSURF ---                                       *
*  This library is distributed under the GNU GPL. Please   *
*  use the contact form at http://www.chrisevansdev.com    *
*  for more information.                                   *
*                                                          *
*  C. Evans, Research Into Robust Visual Features,         *
*  MSc University of Bristol, 2008.                        *
*                                                          *
************************************************************/

#include "utils.h"

#include "integral.h"

//! Computes the integral image of image img.  Assumes source image to be a 
//! 32-bit floating point.  Returns IplImage of 32-bit float form.

void calculateIntegral(int height, int width, int step, float* data, float* i_data);

IplImage *Integral(IplImage *img)
{
  // convert the image to single channel 32f
  #ifdef CVLOADIMAGE
  IplImage *int_img = cvCreateImage(cvGetSize(img), IPL_DEPTH_32F, 1);
  #else
  IplImage *int_img = createImage(img);
  #endif

  // set up variables for data access
  int height = img->height;
  int width = img->width;
  int step = img->widthStep/sizeof(float);
  float *data   = (float *) img->imageData;  
  float *i_data = (float *) int_img->imageData;  
  
  calculateIntegral(height, width, step, data, i_data);
  
  // release the gray image
  #ifdef CVLOADIMAGE
  //cvReleaseImage(&img);
  #else
  //releaseImage(&img);
  #endif

  // return the integral image
  return int_img;
}

void calculateIntegral(int height, int width, int step, float* data, float* i_data)
{
  // first row only
  float rs = 0.0f;
  i_data[0] = 0.0f;
  i_data[step] = 0.0f;
  for(int j=0; j<width-1; j++) 
  {
    rs += data[j]; 
    i_data[step+(j+1)] = rs;
    i_data[j+1]=0.0f;
  }

  // remaining cells are sum above and to the left
  for(int i=1; i<height-1; ++i) 
  {
    rs = 0.0f;
    i_data[(i+1)*step]=0.0f;
    for(int j=0; j<width-1; ++j) 
    {
      rs += data[i*step+j]; 
      i_data[(i+1)*step+j+1] = rs + i_data[(i)*step+j+1];
    }
  }
}

